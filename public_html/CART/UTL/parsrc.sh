#! /bin/sh
#
# parsrc.sh
#    CSV(Excel形式(RFC 4180):ダブルクォーテーションのエスケープは"")から
#    行番号列番号インデックス付き値(line field indexed value)テキストへの正規化
#    (例)
#     aaa,"b""bb","c
#     cc",d d
#     "f,f"
#     ↓
#     1 1 aaa
#     1 2 b"bb
#     1 3 c\ncc
#     1 4 d d
#     2 1 f,f
#     ◇よって grep '^1 3 ' | sed 's/^[^ ]* [^ ]* //' などと
#       後ろに grep&sed をパイプで繋げれば目的の行・列の値が得られる。
#       さらにこれを
#         sed 's/\\n/\<LF>/g' (←"<LF>"は実際には改行を表す)
#       にパイプすれば、元データに改行を含む場合でも完全な値として取り出せる。
#
# Usage: parsrc.sh [-lf<printf_str>] [CSV_file]
# Options : -lf は値として含まれている改行を表現する文字列をprintf形式で指定
#           (デフォルト値は"\\n"。つまり値として改行があると"\n"と表示される)
#
# Written by Rich Mikan(richmikan[at]richlab.org) / Date : May 25, 2013


SO=$(printf '\016')              # ダブルクォーテーション*2のエスケープ印
SI=$(printf '\017')              # 値としての改行文字列エスケープ印
RS=$(printf '\036')              # 1列1行化後に元々の改行を示すための印
US=$(printf '\037')              # 1列1行化後に元々の列区切りを示すための印
LF=$(printf '\\\n_');LF=${LF%_}  # SED内で改行を変数として扱うためのもの

optlf='\\n'
file=''
printhelp=0
i=0
for arg in "$@"; do
  i=$((i+1))
  if [ \( "_${arg#-lf}" != "_$arg" \) -a \( -z "$file" \) ]; then
    optlf=$(printf "_${arg#-lf}_"    |
            tr -d "$SI$RS$US"        |
            tr '\n' $SI              |
            sed 's/^_//'             |
            sed 's/\\/\\\\/g'        |
            sed 's/&/\\\&/g'         |
            sed 's/\//\\\//g'        |
            sed 's/'$SI'/\\'"$LF"'/g')
    optlf=${optlf%_}
  elif [ \( $i -eq $# \) -a \( "_$arg" = '_-' \) -a \( -z "$file" \) ]; then
    file='-'
  elif [ \( $i -eq $# \) -a \( \( -f "$arg" \) -o \( -c "$arg" \) \) \
         -a \( -z "$file" \) ]
  then
    file=$arg
  else
    printhelp=1;
  fi
done
if [ $printhelp -ne 0 ]; then
  cat <<__USAGE
Usage : ${0##*/} [-lf<printf_str>] [CSV_file] 1>&2
Options : -lf は値として含まれている改行を表現する文字列をprintf形式で指定
          (デフォルト値は"\\\n"。つまり値として改行があると"\\n"と表示される)
__USAGE
  exit 1
fi
[ -z "$file"  ] && file='-'

# === データの流し込み ============================================= #
cat "$file"                                                          |
#                                                                    #
# === 値としてのダブルクォーテーションをエスケープ ================= #
#     (但しnull囲みの""も区別が付かず、エスケープされる)             #
sed 's/""/'$SO'/g'                                                   |
#                                                                    #
# === 値としての改行を\nに変換 ===================================== #
#     (ダブルクォーテーションが奇数個ならSI付けて次の行と結合する)   #
awk '                                                                \
  BEGIN {                                                            \
    while (getline line) {                                           \
      s = line;                                                      \
      gsub(/[^"]/, "", s);                                           \
      if (((length(s)+cy) % 2) == 0) {                               \
        cy = 0;                                                      \
        printf("%s\n", line);                                        \
      } else {                                                       \
        cy = 1;                                                      \
        printf("%s'$SI'", line);                                     \
      }                                                              \
    }                                                                \
  }                                                                  \
'                                                                    |
#                                                                    #
# === 各列を1行化するにあたり、元々の改行には予め印をつけておく ==== #
#     (元々の改行の後にRS行を挿入する)                               #
awk '                                                                \
  {                                                                  \
    printf("%s\n'$RS'\n", $0);                                       \
  }                                                                  \
'                                                                    |
#                                                                    #
# === ダブルクォーテーション囲み列の1列1行化 ======================= #
#     (その前後にスペースもあれば余計なのでここで取り除いておく)     #
# (1/3)先頭からNF-1までのダブルクォーテーション囲み列の1列1行化      #
sed 's/[[:blank:]]*\("[^"]*"\)[[:blank:]]*,/\1'"$LF$US$LF"'/g'       |
# (2/3)最後列(NF)のダブルクォーテーション囲み列の1列1行化            #
sed 's/,[[:blank:]]*\("[^"]*"\)[[:blank:]]*$/'"$LF$US$LF"'\1/g'      |
# (3/3)ダブルクォーテーション囲み列が単独行だったらスペース除去だけ  #
sed 's/^[[:blank:]]*\("[^"]*"\)[[:blank:]]*$/\1/g'                   |
#                                                                    #
# === ダブルクォーテーション囲みでない列の1列1行化 ================= #
#     (単純にカンマを改行にすればよい)                               #
#     (ただしダブルクォーテーション囲みの行は反応しないようにする)   #
sed '/['$RS'"]/!s/,/'"$LF$US$LF"'/g'                                 |
#                                                                    #
# === ダブルクォーテーション囲みを外す ============================= #
#     (単純にダブルクォーテーションを除去すればよい)                 #
#     (値としてのダブルクォーテーションはエスケープ中なので問題無し) #
tr -d '"'                                                            |
#                                                                    #
# === エスケープしてた値としてのダブルクォーテーションを戻す ======= #
#     (ただし、区別できなかったnull囲みの""も戻ってくるので適宜処理) #
# (1/3)まずは""に戻す                                                #
sed 's/'$SO'/""/g'                                                   |
# (2/3)null囲みの""だった場合はそれを空行に変換する                  #
sed 's/^[[:blank:]]*""[[:blank:]]*$//'                               |
# (3/3)""(二重)を一重に戻す                                          #
sed 's/""/"/g'                                                       |
#                                                                    #
# === 値としての改行のエスケープ(SI)を代替文字列に変換 ============= #
sed 's/'$SI'/'"$optlf"'/g'                                           |
#                                                                    #
# === 先頭に行番号と列番号をつける ================================= #
awk '                                                                \
  BEGIN{                                                             \
    l=1;                                                             \
    f=1;                                                             \
    while (getline line) {                                           \
      if (line == "'$RS'") {                                         \
        l++;                                                         \
        f=1;                                                         \
      } else if (line == "'$US'") {                                  \
        f++;                                                         \
      } else {                                                       \
        printf("%d %d %s\n", l, f, line);                            \
      }                                                              \
    }                                                                \
  }                                                                  \
'